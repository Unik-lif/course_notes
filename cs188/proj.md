## Proj1
### Q1-Q4
前几个都算是课程的练手，对着伪代码来写就可以了。

可能需要注意的是A*会重新评估所有的结点到目标点的距离，因此即便已经遍历过了，也需要重新检查是否可能有更短的路径。为了达到这个目的，需要在扩展的时候，同步更新遍历的数据集合中的最短路程。

### Q5
利用一个新的list来记录当前路径是否已经访问了某个结点

特别的，需要注意要单独为每个fringe中的点维持一个新的list，因此deepcopy是必要的，否则路径将会彻底乱掉。

为了避免这个问题，我直接用位运算来做。

注意确实还是有很多容易搞错的细节，比如nextx和nexty不要和state搞混了
### Q6
最简单的方式其实就是找一个离自己曼哈顿距离最远的就好了

### Q7
写了一个丑陋的方法判断点在不同区域上的情况，分别讨论估算。如果在外头，则先到最近的点，再前后交叉左右判断

拿满分是没问题，但bonus拿不到
### Q8
直接用UniformCost来做就好了，它就是干这个的

## Proj2
### Q1
GPT太聪明了，做这个实验还是避免在代码仓库中使用它吧。

GPT考虑了我没有考虑的东西，比如当前的Ghost状态和与自身的距离。但实际上只考虑最近的minFoodDistance，似乎还是很快就能满足题目中的要求。
### Q2
### Q3
### Q4
### Q5