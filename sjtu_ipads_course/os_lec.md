## Lec1: 简介
操作系统是在硬件和应用之间的软件层。

操作系统 = 管理 + 服务

但是管理和服务的目标有可能存在冲突点，因为服务的目标是为了让单个应用的运行效率最大化，而管理的目标是让系统的资源整体利用率最大化。

操作系统需要把应用当做不可信的实体。

学习操作系统的理由：伟大，无需多言

课程特点：抽象到具体

把复杂留给自己，把简单留给用户

一些疑难问题：
- 文件描述符的可扩展性（可以在多核高效地使用吗？）
- IPC巨大开销，比函数调用慢16倍 （隔离与性能的Tradeoff）

苹果开发系统的哲学：
- timely: 迭代式开发
- dependable: 逐步增加功能提高可靠性与安全性
- adaptable: PC -> iPhone.
- simple yummy: Clang报错简单，对于用户很友好
- Efficient: 根据硬件发展，使用OpenCL，充分利用硬件性能

chcore: 教学科研操作系统
- 微内核架构：把操作系统服务更多放到用户态
- 微内核崩溃概率更低，因为内核态模块数要少很多，可靠性上会比较强
- 微内核利于那个形式化验证

## Lec2: 理解硬件
冯诺依曼结构：
- CPU通过循环来不断解析指令
- 内存用于存储指令和数据

冯诺依曼结构的局限
- CPU与内存交互引发的内存墙问题
- 数据与指令不区分，指令等数据或数据等指令
- 串行顺序处理，缺乏数据并行能力

为什么选择ARM？
- 智能手机的模式指令集
- 正在走向服务器

相对成熟的ARM版本: ARMv8
- 支持A64指令集
- 支持A32、T32、T16指令集

Aarch64体系结构
- 有栈寄存器
- 有异常链接寄存器
- 有多个程序状态寄存器，切换时保存PSTATE

相对于x86的优势，编译时有更高的寄存器层优化自由度

AArch64有一些很有意思的性质，比如维护两份页表。具体细节请参阅手册。

## Lec3: 中断、异常与系统调用
OS对于外设应该用什么方式处理比较好？
- 轮询
- 中断

当然也有结合的方式，在中断后进行轮询处理。需要看处理的效率，进行选用，而且经常会出现结合使用的方式。 

### 通用概念
中断：
- 外部硬件设备产生的信号
- 异步：产生原因和当前执行的指令无关，如程序被磁盘读所打断

异常：
- 软件的程序执行而产生的时间
- 包括系统调用
- 同步：产生和当前执行或试图执行的指令相关

不同体系结构的对中断与异常的术语上的定义有所不同：
1. 中断 -> 异步异常（AArch64） -> 中断 （x86-64）
2. 异常 -> 同步异常（AArch64） -> 异常 （x86-64 Fault/Trap/Abort）

在AArch64中的中断存在两种类别：
- 重置：最高级别的异常，用于执行代码初始化CPU核心
- 中断：CPU外部信号触发，打断当前执行

在AArch64中的异常存在两种类别：
- 中止：失败的指令获取或者数据访问
- 异常产生指令：SVC/HVC/SMC

x86-64术语：
- 中断：设备产生、异步
1. 可屏蔽：设备产生的信号，通过中断控制器与处理器相连，可被暂时屏蔽
2. 不可屏蔽：一些关键硬件的崩溃
- 异常；软件产生
1. 错误：缺页异常，段错误等
2. 陷阱： 无需恢复，比如说断点、系统调用
3. 中止：严重的错误，不可以恢复

AArch64中的中断控制器需要考虑的问题：
- 如何指定不同中断的优先级（如果在低优先级中断处理中，出现了高优先级的中断，应该怎么办？或者说，出现嵌套中断的情况，应该怎么处理？）
- 中断交给谁来处理
- 如何与软件协同

向量中断与非向量中断：
- 非向量中断会有相同的处理地址

现行AArch64的中断控制：通用中断控制器GIC
- 中断类型变多，将中断分发给不同的核进行处理
- 主要功能是分发，并提供给每个CPU对应的接口