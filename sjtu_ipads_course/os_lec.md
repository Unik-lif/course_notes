## Lec1: 简介
操作系统是在硬件和应用之间的软件层。

操作系统 = 管理 + 服务

但是管理和服务的目标有可能存在冲突点，因为服务的目标是为了让单个应用的运行效率最大化，而管理的目标是让系统的资源整体利用率最大化。

操作系统需要把应用当做不可信的实体。

学习操作系统的理由：伟大，无需多言

课程特点：抽象到具体

把复杂留给自己，把简单留给用户

一些疑难问题：
- 文件描述符的可扩展性（可以在多核高效地使用吗？）
- IPC巨大开销，比函数调用慢16倍 （隔离与性能的Tradeoff）

苹果开发系统的哲学：
- timely: 迭代式开发
- dependable: 逐步增加功能提高可靠性与安全性
- adaptable: PC -> iPhone.
- simple yummy: Clang报错简单，对于用户很友好
- Efficient: 根据硬件发展，使用OpenCL，充分利用硬件性能

chcore: 教学科研操作系统
- 微内核架构：把操作系统服务更多放到用户态
- 微内核崩溃概率更低，因为内核态模块数要少很多，可靠性上会比较强
- 微内核利于那个形式化验证

## Lec2: 理解硬件
冯诺依曼结构：
- CPU通过循环来不断解析指令
- 内存用于存储指令和数据

冯诺依曼结构的局限
- CPU与内存交互引发的内存墙问题
- 数据与指令不区分，指令等数据或数据等指令
- 串行顺序处理，缺乏数据并行能力

为什么选择ARM？
- 智能手机的模式指令集
- 正在走向服务器

相对成熟的ARM版本: ARMv8
- 支持A64指令集
- 支持A32、T32、T16指令集

Aarch64体系结构
- 有栈寄存器
- 有异常链接寄存器
- 有多个程序状态寄存器，切换时保存PSTATE

相对于x86的优势，编译时有更高的寄存器层优化自由度

AArch64有一些很有意思的性质，比如维护两份页表。具体细节请参阅手册。

## Lec3: 中断、异常与系统调用
OS对于外设应该用什么方式处理比较好？
- 轮询
- 中断

当然也有结合的方式，在中断后进行轮询处理。需要看处理的效率，进行选用，而且经常会出现结合使用的方式。 

### 通用概念
中断：
- 外部硬件设备产生的信号
- 异步：产生原因和当前执行的指令无关，如程序被磁盘读所打断

异常：
- 软件的程序执行而产生的时间
- 包括系统调用
- 同步：产生和当前执行或试图执行的指令相关

不同体系结构的对中断与异常的术语上的定义有所不同：
1. 中断 -> 异步异常（AArch64） -> 中断 （x86-64）
2. 异常 -> 同步异常（AArch64） -> 异常 （x86-64 Fault/Trap/Abort）

在AArch64中的中断存在两种类别：
- 重置：最高级别的异常，用于执行代码初始化CPU核心
- 中断：CPU外部信号触发，打断当前执行

在AArch64中的异常存在两种类别：
- 中止：失败的指令获取或者数据访问
- 异常产生指令：SVC/HVC/SMC

x86-64术语：
- 中断：设备产生、异步
1. 可屏蔽：设备产生的信号，通过中断控制器与处理器相连，可被暂时屏蔽
2. 不可屏蔽：一些关键硬件的崩溃
- 异常；软件产生
1. 错误：缺页异常，段错误等
2. 陷阱： 无需恢复，比如说断点、系统调用
3. 中止：严重的错误，不可以恢复

AArch64中的中断控制器需要考虑的问题：
- 如何指定不同中断的优先级（如果在低优先级中断处理中，出现了高优先级的中断，应该怎么办？或者说，出现嵌套中断的情况，应该怎么处理？）
- 中断交给谁来处理
- 如何与软件协同

向量中断与非向量中断：
- 非向量中断会有相同的处理地址

现行AArch64的中断控制：通用中断控制器GIC
- 中断类型变多，将中断分发给不同的核进行处理
- 主要功能是分发，并提供给每个CPU对应的接口

## Lec12: 文件系统
文件系统可用的磁盘块并非磁盘全部空间，需要存放一些区域metadata信息

文件的索引结点：inode
- 记录文件常用元数据
- 具体文件数据的位置

链接：
- 软连接：方便跳转到其他文件夹下
- 硬链接：在目录中加了entry，同一个文件会有两个文件夹指向

Extent机制
- 为了存一个G的内容，可能要用几个MB来做inode号存储，其实还是一个比较大的开销
- 如果大文件，数据块在物理上如果连续，只需要保存起始块地址和长度就行了

inode并非唯一的方式
- 还有基于TABLE的文件系统，比如FAT文件系统
### FAT
会为文件分出来一些数据簇

在表中存放下一个数据簇的位置，通过FAT文件分配表来进行向下读取
- 先读目录项，得到第一个cluster对应的ID
- 去FAT表找下一个的索引，再去数据簇中去读下一个
- 在两个数据表中来回地进行读取

FAT有一些问题，仔细思考，包括为什么FAT不支持link等，一些开放性问题
### NTFS
性能更好且更加复杂，主要数据结构是MFT

MFT存放了文件所在位置和文件名等等
- 将文件分为三类：非常驻文件，常驻文件，目录项
- 大文件是非常驻的，会在数据区的B+树和区段来做
- 小文件如果很小，甚至可以直接内嵌到MFT中，就不用放到树里存了
- 目录项则是包含文件名和文件ID，文件ID就是在MFT中的序号

### VFS
如何在一个系统中同时支持多个文件系统？
- 由Linux的VFS定义一些系列接口
- 具体的文件系统来实现这些接口

VFS是抽象，不是实现
- 目标是让操作系统使用多个文件系统
- 每个文件系统都有自己的根节点，怎样才能合在一块？

VFS维护一个统一的文件系统树
- 操作系统内核启动时会挂载一个根文件系统
- 其他文件系统可以挂载在文件系统树的目录上

Linux的VFS定义的inode相关操作接口
- 最后由EXT2或者EXT4来进行调度
- 本质上就是OOP，面向对象编程一样
- EXT2和EXT4是很容易接上去的

问题：没有inode概念的FAT系统，怎样挂载到VFS上？
- 需要让FAT驱动提供一个inode的抽象

VFS -> FAT驱动 -> FAT文件系统 -> 磁盘

- 磁盘上的FAT并没有inode：硬盘上的数据结构
- 内存中的VFS需要inode：在FAT场景下这边的inode是只在内存中的数据结构

- 即便是原生的EXT2，其inode和VFS的inode也是有一定区别的

内存中的inode由VFS来定义，磁盘中的inode可以不存在，反正由底下的文件系统来定义

文件系统的icache和dcache是内存上的，和CPU用的icache和dcache不是一个意思，文件系统中说的是inode cache和directory cache

### APFS
苹果的文件系统

是文件层面的复制，只复制关键元数据，而其他部分则COW共享

快照方式
- 同样是用COW来做
- 将inode表/树根这一系列指针给记录下来，对数据做COW防护

git其实是一个内容寻址的文件系统
- 所有对象都保存在.git/objects目录中
- 切换分支会从objects中重新拿
- - BLOB对象：文件
- - 树对象：目录
- - 提交对象：commit对象，每个commit对应一个树对象

SQLite也是一个文件系统

FUSE：用户态文件系统框架
- 让用户态实现文件系统的接口