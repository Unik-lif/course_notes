## 阅读记录
用词的变化：
- 一开始机器没有什么多线程的，所以就只有进程
- 后来出现了多线程的进程，所以出现了lightweight thread这种说法
- 最后达成了一致协议，出现了process和thread的明显区分

dual-mode的出现
- 一开始是用一个软件层的interpreter，对指令做逐步的解析，同时检查其安全性
- 后来发现大部分指令可能是无害的，不会对安全性造成影响
- 于是把interpreter的功能写到了硬件上，这就是user-mode和kernel-mode的由来

直接使用物理地址，并且采用Base & Bound方案的劣势
- heap和stack的大小在变化
- 内存没法共享
- 物理地址得写死，否则需要复杂的动态管理
- 内存碎片化

为了更好使用内存，添加虚拟地址这一层抽象