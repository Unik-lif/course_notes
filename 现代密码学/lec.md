## lec 1
- confidential
- intergrity
- authentication
- Non-repudiation 不可否认性（仅有公钥能够达成这个目标，对称密码是不行的）

对称加密的时候，在我们知道了key和message之后，是否有必要还需要对解密算法或者加密算法做加密

密钥生成算法：需要尽可能在密钥空间中随机均匀地生成一个密钥

对称加密三个算法:
- 生成算法
- 加密算法
- 解密算法

- <- 这个符号表示不确定，存在很多的随机性
- := 这个符号表示确定
- IV: initial value
- nounce: number once

科克霍夫法则：
- 加密的方针本身并不是机密的，我们得默认攻击者是知道的
- 加密流程中，唯一算是秘密的只有密钥，而不是加密算法
- 这种法则更利于存放key，而不是algorithm，一般algorithm大小还挺大的，现在只要存放一个密钥就行了，这就很方便
- 更改一个密码算法，要比更改密钥的代价高很多

基于字节的移位密码，或许是古典移位密码产生新生命的东西
- 利用Byte-wise shift cipher
- 但是他的密钥空间还是很小，看起来一共只有128bytes （回去看书看一眼就行）
- 用ASCII来做，一共有256个，但只有128个


古典密码很不安全，但是还是有lessons taught
- 需要用更大的密钥空间
- 没准有些有意思的细节可以帮助加速判断目前得到的信息是否是正确的

弗吉尼亚密码
- 密钥是十四个字母
- 由于没有上下文，这件事情做起来比较困难
- 最后攻破的方式其中之一是词频分析，第二种方法是把所有的词拿过来做统计分析，按照自然语言，词频乘积的和大概是0.065，利用排序不等式就能做出来
- 怎么猜测密钥长度：用类似的0.065值来做，有比较大的区分度

课后任务：弗吉尼亚密码破译这边我们能看出来什么？

下去阅读一下第一章

关于秘钥长度，课上我没有理解清楚，这是我9月26日自己思考讨论得到的：
```
Eidos:
我想想我是否搞清楚了你说的意思：

假设我猜对了秘钥长度，那么即便我不知道具体移位了多少位，只要字符够多，那么我单拎出来每一组，本质上都是某个英文字符，加上这个组所对应的固定的移位长度。我真正该care的是每一组中的字符，他们在经过移位后，虽然表示方式出现了变化，但是IC值是不变的，只不过可能原本高频的e经过我们所不大确认的位移变成其他字符了。

但是如果我没有猜对秘钥长度，那么我单拎出来的这个组，就并不是原本一个字目表通过一个固定的移位得到的了，因为肯定会有其他不同的移位长度，移位长度并不固定，那就不能视作自然语言通过移位密码处理后的结果，因此这个IC值将不符合本身英文中的规律了。

在这里就能通过IC值变化得知最终我们是否猜对了秘钥的长度。

yuanbao:
​​完全正确！您的理解100%准确，总结得也非常精辟！​​
您已经抓住了弗里德曼测试最核心、最精妙的逻辑。让我用您的表述来再清晰地复述一遍，以确认我们想得完全一样：
对您理解的确认和升华
​​猜对密钥长度时：​​
您说：“...单拎出来每一组，本质上都是某个英文字符，加上这个组所对应的固定的移位长度。”
​​完全正确！​​ 这一组内的所有明文字母，都被​​同一个​​密钥字母（即同一个移位量）加密。因此，这组密文在统计上​​等价于​​对一段纯英文文本应用了一次简单的凯撒密码。
​​IC值的不变性：​​
您说：“...IC值是不变的，只不过可能原本高频的e经过位移变成其他字符了。”
​​这正是关键！​​ 移位操作（凯撒密码）是一种​​单表替换​​，它不会改变字母的​​相对频率分布​​。它只是把整个频率分布图（直方图）在字母表上​​平移​​了一段距离。e的高峰平移后变成了（比如）J的高峰，但高峰的​​高度​​（即出现的集中程度）没有变。而IC值计算的正是这种“集中程度”，所以它​​在平移下保持不变​​。
​​猜错密钥长度时：​​
您说：“...这个组...并不是原本一个字目表通过一个固定的移位得到的了，因为肯定会有其他不同的移位长度...”
​​一针见血！​​ 如果您猜错了长度，您的分组就是错误的。您会把被​​不同​​密钥字母（即​​不同​​移位量）加密的明文字母强行塞进同一组。这相当于把多个不同平移后的频率分布图​​叠加平均​​了。多个分布一平均，结果就是整个分布变得更“平坦”、更“均匀”。高峰被削平了，谷底被填高了。这种更均匀的分布，其IC值自然会下降到接近随机文本的水平（~0.038）。
​​最终的判断逻辑：​​
您说：“在这里就能通过IC值变化得知最终我们是否猜对了秘钥的长度。”
​​完美！​​ 整个方法的逻辑就是：​​寻找那个能使分组后文本的IC值最大化（最接近0.065）的密钥长度k。​​ 这个k就是我们的最佳猜测。

```
## takehome 1
弗吉尼亚密码的变式，即直接采用bytes来做（请看课件例子），我们仍按照两步走
- 确认秘钥长度
- 确认key

和常规用英文不一样，此时需要对ASCII明文的文本表示有一个频次认知吗？
- ascii中能算是有意义的字符大概是33号到126号，其他的则不算
- 和字母模式类似，按照permutation order，值会远大于uniform值（这个似乎本质上还是因为类似英文词频的说法，因为ascii表示要是有意义，可能还是要更多表示英文文本）

第二步，对于秘钥的内容
- 明文需要是在32-126号之间
- space character的出现频次是比较高的
- 英文本身的性质依旧生效，只不过由于ascii码表示的范围更多，这个值不见得和之前一样，但是还是会显著地高一些

算法的复杂度
- 如果秘钥的长度是在1到L
- 确认秘钥的长度在讲义中写的是O(L)，如果把密文长度视作不是特别长可能还真是，一般来说也就是挑选一组来计算一下，然后从1到L各算一下，进行一次比较，不过我并不倾向于这个答案，如果密文的长度是N，那么每一组的长度是N/L，最后需要花费的复杂度是O(N)
- 确认秘钥内容的话则是从1到L组逐一算个有限次数（因为ASCII还是英文字母，总数都不是很多）

当然这个攻击还是需要比较长的密文会比较好，对于比较短的密文，可能会多花点力气

我个人感觉弗吉尼亚密码能让我学到的可能是，
- 得想办法摒弃自然语言规律所带来的一些东西，因为这些问题一定是会被统计学和词频分析大大简化
- 得想办法把密码不用弄成很多很多单元以某种相同规律组织的方式，把密文信息想办法以比较零散的方式扩散开来使用，也许这样会比较好

## lec 2
如何证明某个加密方案它是安全的？

如何定义 secure 这个次的意思？

heuristic design：直觉性，经验性的启发性设计

现代密码学的特点
- formal definitions: 有一个精确的数学上的模型，并且对于安全意味着什么有一个清晰的定义
- assumptions: 对于假设说的很精确，并且要避免模糊
- proofs of security: 尽可能地摆脱设计-破坏-补丁的循环

设计目的非常重要：如果目的都不明确，怎么知道自己是否达到了自己的目标？

某种方法是否满足了需求？
- 可能会有多种方法适合，有些方法可能性能烂一些，但是能够提供更加多的安全定义

假设：密码学需要computational assumptions
- 至少得直到我们能够证明P不等于NP

proofs of security: 提供一个详尽假设，用来证明某个构造算式在某个特殊的假定下满足给定的定义

但是同样有问题与限制，尤其是假设和攻击对应真实的威胁模型存在差异的情况下

一个相对好的定义：不管攻击者之前知道了什么关于明文的信息，密文信息中不允许泄露任何关于明文的额外信息

M和K需要独立：从M中生成K，或者从K中生成M，都会带来很多问题

一个非正式直观的理解：攻击者对于明文的认知，本质上是攻击者对于明文分布情况的了解。因此如果能够做到完美的安全，本质上就是让攻击者对于密文的观察，并不会改变攻击者对于明文分布情况的认知

更加正式一点就是某个条件概率上的问题：$\forall m \in \mathbb{M}， Pr[M=m |C=c] = Pr[M=m]$

说白了就是知道密文并不会影响概率的判断，这两件事情是无关变量

之后还有一个折中方式用于密码的使用，本质上是practical特性

## lec 3
optimal: 说白了就是K空间大于等于M空间

但是这个就实用上可能不是特别好，可能要把假设再弱化一下

完善保密性的等价定义，完善不可区分性
- 证明在手机相册里拍下来了
- 主要还是用课本中的定义，我这边有些步骤没有写清楚
- 最后得到结果的话，主要是二者取其一的概念

均匀性：
- 一个概率分布，而不是一个确定比特串能说其均匀
- 均匀指的是概率分布

伪随机性:
- 不能和一个均匀的分布区分开来
- 这个指的也是一个概率分布，而不是某个特定的比特串

### Read
Concrete Approach: 不够具体，只说了某个scheme被攻击者跑t seconds之后，最多有$\epsilon$概率被攻破

主要是缺乏其他细节的描述

Asymptotic Approach: 渐进式的方法

A scheme is secure if any ppt adversary succeeds in breaking the scheme with at most negligible probability.

这个描述的方式好处在于，不像concrete approach那样固定而呆板了
- efficient adversaries: 可以用多项式速度来破解秘钥的人
- small probabilities of success: 比任何多项式的倒数还小的概率

PPT: probabilistic polynomial-time


## lec 4
stateful var: 带了状态的版本（其他的变式）

明文长度：CBC一定是需要扩充的，组间有依赖关系，如果不打组，性能会烂掉，此外，也很容易猜到

CTR mode具体的3/4 n 怎么取，（不只是3/4），可以根据需求动态地进行选择