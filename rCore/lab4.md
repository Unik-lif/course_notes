## 第四章：地址空间
### 引言：
物理内存是操作系统的重要资源，为了让“争抢”不再成为苦恼，操作系统需要达到动态使用内存的目标。通过隔离应用的物理内存空间保证应用之间的安全性，把“有限”物理内存变成“无限”虚拟内存，这是操作系统的一系列重要目标。

`Lab3`中存在的遗留问题恰是上一章给我造成一定困扰的问题，即为何应用程序也需要知道自身代码段在内存中的布局情况。在这一章似乎该问题能够得到不错的解决。如果不解决这个问题，似乎有下面几个较为棘手的问题：
1. 内核提供的内存访问接口不够透明，因此应用程序需要在了解计算机物理内存空间布局的情况、规划自身需要被加载的地址位置的情况下才能正常工作，这非常反人类。
2. 内核并没有对应用的访存行为做限制，没有添加一些保护措施。每个应用都有计算机系统中整个物理内存的读写权力，会造成很多安全上的麻烦。
3. 目前应用的内存空间在使用前就已经被限定死了，内核不可以动态灵活地分配可用的内存空间。

先驱者：`Atlas Supervisor`操作系统
#### 代码改进方向：
前期工作：
1. 将应用程序的起始地址修改为`0x10000`.
2. 为内核添加连续分配内存的功能.
3. 利用物理页帧为单位分配和回收物理内存.

页表建立：
1. 页表项的数据结构搭建.
2. 多级页表起始页帧与占用的物理页帧记录信息.

分页机制：
1. 如何获取应用的ELF中的有效信息，如何解析他们.
2. 页表切换所带来的一些挑战.

### 动态内存分配
相较于动态内存分配，静态分配存在的问题源于我们再程序中对变量的声明往往仅能应对一部分需求，不够灵活。

动态内存分配使用的是堆内存空间，应用所依赖的基础系统库会直接通过系统调用来向内核请求增加或者缩减应用地址空间内堆的大小。不过这样做也回有不太好的地方，多次做似乎会造成内存空间的浪费，让无法被应用使用的空闲内存碎片变得比较多。这一部分碎片无论是内部碎片还是外部碎片，对于用户来说均是不可见的。

动态分配的缺点确乎是碎片化和内存分配算法带来的更大性能开销，很有可能成为相关内存使用和释放时的巨大瓶颈。

在这一章同样对`Rust`相关的智能指针做了一系列的梳理：

http://rcore-os.cn/rCore-Tutorial-Book-v3/chapter4/1rust-dynamic-allocation.html#rust-heap-data-structures

