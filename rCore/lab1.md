## 第一章：基本执行环境
### 第一条指令（基础篇）
#### Qemu的启动流程
Qemu的文档其实也是一个大坑，要谨慎地查阅和学习。在Qemu开始执行任何指令之前，首先把两个文件加载到Qemu的物理内存中。

首先，用于当做BootLoader的文件rustsbi-qemu.bin要撞到物理地址为`0x80000000`开头的区域上，同时要把镜像`os.bin`加载到物理地址为`0x80200000`的位置上。

这么装载的原因处于Qemu本身的启动流程：
1. Qemu内固化的小段汇编负责。Qemu的CPU先会初始化为0x1000，因为Qemu的第一条指令位于这个地址中。执行完这一部分小指令后，它会跳转到物理地址`0x80000000`，进入第二个阶段。
2. Bootloader负责。因此，第二阶段的rustsbi-qemu.bin文件会被放在这个位置上。Bootloader将会对计算机进行一些初始化的工作，并且跳转到下一阶段软件的入口，在Qemu上即可实现将计算机控制权移交给镜像`os.bin`的工作。特别的，**对于不同的 bootloader 而言，下一阶段软件的入口不一定相同，而且获取这一信息的方式和时间点也不同：入口地址可能是一个预先约定好的固定的值，也有可能是在 bootloader 运行期间才动态获取到的值。** RustSBI的行为则是固定下一阶段入口地址为`0x80200000`。
3. 内核镜像负责。

真实机器的流程：
1. 在ROM上将后续的BootLoader代码等等载入到物理内存中去，之后再跳转到适当的位置将控制权转移给BootLoader。
2. BootLoader完成一些CPU的初始化工作，将操作系统的镜像从硬盘加载到物理内存中，跳转到适当的位置后，把控制权提供给内核镜像。
3. 系统镜像开工。

#### 链接器
在模块化编程的时候，每个模块都会提供给其他模块公开的全局变量等信息供他们访问。这些信息被分为外部符号和内部符号。内部符号在转化为`.o`文件后，就已经确定下来地址了，但是外部符号则还没有明确。为此，需要利用符号表存储这些外部符号以确定地址。

出于重定位的原因，即便内部符号在目标文件内已经有了一个地址，其也需要被存储在符号表之中。

### 第一条指令（实践篇）
以内联形式`include_str！`写进去的汇编文件，其中的注释是不可以有的，很自然地会报错。

#### linker.ld
在这边通过查看源码可以大体上了解排布的方式，虽然其中的原理奥秘不能完全搞清楚，但也足以窥其一斑。

#### 加载
Qemu不支持动态链接，加载时的原理也较为简单，因此偶尔需要丢弃掉元数据，才能让其较好地工作。

#### 启动时的初始代码：
简要的查看一下pc处往下的十条指令长什么样。
```
(gdb) x/10i $pc
=> 0x1000:  auipc   t0,0x0   ;; t0: 0x00000 000 + PC = 0x00001 000
0x1004:     addi    a1,t0,32 ;; a1: 0x00001 020
0x1008:     csrr    a0,mhartid ;; 从mhartid寄存器中读取hardware thread id到a0
0x100c:     ld      t0,24(t0) ;; load sth from address 0x00001 018, store in t0. we get 0x8000 0000。一个地址一个byte，正好得到0x8000 0000
0x1010:     jr      t0 ;; jump to 0x8000
0x1014:     unimp
0x1016:     unimp
0x1018:     unimp
0x101a:     0x8000
0x101c:     unimp
```
#### 为内核支持函数调用 Q & A
看这一节之前先小测一手，感谢UCB的61c课程给我打了不错的基础：
1. 如何使得函数返回时能够跳转到调用该函数的下一条指令，即使该函数在代码中的多个位置被调用？
- 在栈上存好return address就可以了。
2. 对于一个函数而言，保证它调用某个子函数之前，以及该子函数返回到它之后（某些）通用寄存器的值保持不变有何意义？
- 还原场景。
3. 调用者函数和被调用者函数如何合作保证调用子函数前后寄存器内容保持不变？调用者保存和被调用者保存寄存器的保存与恢复各自由谁负责？它们暂时被保存在什么位置？它们于何时被保存和恢复（如函数的开场白/退场白）？
- 这里存在着callee和caller的calling convention，如果要实现保存和恢复的话，需要在栈上多存存。
4. 在 RISC-V 架构上，调用者保存和被调用者保存寄存器如何划分的？
- t类寄存器可以随便用，s不可以。
5. sp 和 ra 是调用者还是被调用者保存寄存器，为什么这样约定？
- ra需要被调用者保存返回，sp也需要被调用者寄存器好好保存。
1. 如何使用寄存器传递函数调用的参数和返回值？如果寄存器数量不够用了，如何传递函数调用的参数？
- 使用好调用的规范就行了，如果寄存器数量不够，你就存在栈上呗。

#### 实验与练习