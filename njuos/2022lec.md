## Lec1:
最重要的意义：卡脖子没有那么可怕，要接受正确的训练和知识。你真的可以变强。

操作系统：
- 让程序跑起来变得容易（OSTEP）
- 对于他的定义本来就是很模糊的
- 精准的定义毫无意义

操作系统如何从简单形式出现如此多的衍生意义：
- 了解历史，初代计算机对于内存的天才设计：延迟线内存，就像我们把多个球扔到空中，把数据放在通路中转。

最早的计算机
- 重新变成需要重新接线
- 没有操作系统，能把程序放上去运行就很不错了，程序直接用指令来操作硬件
- 但至少能够帮助人算很长很久的工作

1950的计算机
- 1970年以前的计算机发展其实更快，尤其是在存储技术出现突破之后
- 已经有了更快更小的逻辑门，有了新的磁芯内存，已经和 DRAM 很像了，像是二维的网格

1950的程序
- Fortran出现
- 希望使用计算机的人变多，希望调用 API 而不是直接访问设备
- 通过读手册打孔，需要流程图：但是今天不需要，我们有现代的工作方式

1950年的操作系统
- 管理多个程序排队使用
- 操作系统的概念出现
- Disk Operating Systems(DOS)：操作系统出现了设备、文件、任务等对象和 API ，需要换卡
- 概念的出现是很自然的

1960年的计算机
- 更多程序
- 能够同时把多个程序装载进入内存，让程序可以交替运行：multiprogramming，切换
 
1970年：
- Unix
- 功能已经和现代一致，基本能够完成今天能做的全部事情

三个根本问题：
- 服务于谁：程序 = 状态机
- 提供什么服务？对象+API
- 如何实现操作系统？C程序而已

## Lec2:
本次课程主要内容
- 程序的状态机模型
- 操作系统上的最小程序工作原理

操作系统是状态机
- 状态机行为：可以用数学公式和状态转移图来表示，同样也可以用写程序来做到

程序也是状态机
- 所有的程序都运行在数字系统，数字系统是状态机，所以程序都是状态机

任何真正的理解都应该落到可以执行的代码，在了解了状态机模型之后，我们理应可以写出非递归的汉诺塔。

可以将任何递归程序转化为非递归。
- 状态 = stack frame 列表 + 全局变量
- 初始状态 =  全局变量初始化
- 迁移 = 执行 top stack frame PC 语句，让 PC 递增，函数调用与返回就是对 frame 的操作