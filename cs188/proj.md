## Proj1
### Q1-Q4
前几个都算是课程的练手，对着伪代码来写就可以了。

可能需要注意的是A*会重新评估所有的结点到目标点的距离，因此即便已经遍历过了，也需要重新检查是否可能有更短的路径。为了达到这个目的，需要在扩展的时候，同步更新遍历的数据集合中的最短路程。

### Q5
利用一个新的list来记录当前路径是否已经访问了某个结点

特别的，需要注意要单独为每个fringe中的点维持一个新的list，因此deepcopy是必要的，否则路径将会彻底乱掉。

为了避免这个问题，我直接用位运算来做。

注意确实还是有很多容易搞错的细节，比如nextx和nexty不要和state搞混了
### Q6
最简单的方式其实就是找一个离自己曼哈顿距离最远的就好了

### Q7
写了一个丑陋的方法判断点在不同区域上的情况，分别讨论估算。如果在外头，则先到最近的点，再前后交叉左右判断

拿满分是没问题，但bonus拿不到
### Q8
直接用UniformCost来做就好了，它就是干这个的

## Proj2
### Q1
GPT太聪明了，做这个实验还是避免在代码仓库中使用它吧。

GPT考虑了我没有考虑的东西，比如当前的Ghost状态和与自身的距离。但实际上只考虑最近的minFoodDistance，似乎还是很快就能满足题目中的要求。
### Q2  
搞清楚每一层的深度表示的是什么，之后就是一个工程问题

### Q3
仔细理解清楚$\alpha, \beta$具体是做什么的，之后这件事情就不难理解了，多多演绎推理思考就好

### Q4
这个加起来直接算一下就好了

### Q5
可以考虑到ghost，dot，以及特效药的距离，选值需要仔细一点，不能太狂野，慢慢调试就行了

## Proj3
并不困难，关键是理解清楚，之后就只是巩固和复习。写码时有一些函数的作用可能不太清楚，理解可能也很难一下子到位，所以建议从最顶层的函数来写，像SICP中提示的那样，自顶向下地去做，否则确实很容易搞混。
### Q1
对着公式敲就好，注意iteration得用上，不然就搞错了
### Q2
蛮有意思的，不过多多尝试一下值就好。唯一需要注意noise看起来是确认的，我估计是算着期望来的，感觉也挺合理。

绕远路的方式需要noise设置的比较高
### Q3，Q4，Q5
本质上是工程问题，慢慢写就行
### Q6
注意所有的w是同时更新的，这一点很容易在写代码的时候遗漏掉，以及一开始的w是没有值的，需要自己赋值0然后再慢慢学习

其他的就很简单啦！